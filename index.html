<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHIB Ads WebApp</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap'); 

        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Vazirmatn', Arial, Helvetica, sans-serif;overflow:hidden;background: #0d0c1d;}
        
        .app-screen {
            position: fixed;
            inset: 0;
            background: url('img.png') no-repeat center center;
            background-size: cover;
            transition: opacity .5s ease-in;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none; 
            z-index: 10; 
        }
        .app-screen.visible {
            opacity: 1;
            pointer-events: auto;
            z-index: 20; 
        }

        /* Loading Screen - Minimalistic Spinning Circle */
        .loading-screen{
            position:fixed;inset:0;
            background: #0d0c1d;
            display:flex;flex-direction:column;justify-content:center;align-items:center;
            z-index:9999;transition:opacity .5s ease-out;
        }
        .loading-screen.hidden{opacity:0;pointer-events:none}
        
        .spinner-circle {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.1);
            border-top: 8px solid #00ffff; /* Neon color */
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); /* Neon glow */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* End of Loading Screen */

        /* Main Screen */
        .main-screen{
            background-color: #f0f0f0; 
        }
        
        .main-content{flex:1;display:flex;justify-content:center;align-items:center}
        
        /* User Circle */
        .user-circle{
            position:absolute;top:20px;left:20px;width:70px;height:70px;border:2px dashed #ccc;
            border-radius:50%;display:flex;flex-direction:column;justify-content:center;
            align-items:center;cursor:pointer;transition:all .3s ease;z-index:100;overflow:hidden
        }
        .user-circle:hover{border-color:#4a90e2;background:rgba(74,144,226,.05)}
        .user-circle img{width:100%;height:100%;object-fit:cover;border-radius:50%;display:none}
        .user-circle .placeholder{color:#999;font-size:12px;text-align:center}
        
        .user-username{
            position: absolute;
            top: 95px;
            left: 20px;
            width: 70px;
            font-size:13px;color:#555;white-space:nowrap;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .user-id{
            position: absolute;
            top: 115px;
            left: 20px;
            width: 70px;
            font-size:11px;color:#888;white-space:nowrap;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .balance{position:absolute;top:20px;right:20px;background:#fff;border:1px solid #ff5a5a;border-radius:12px;padding:8px 12px;font-family:'Courier New',monospace;font-size:16px;color:#ff2a2a;text-shadow:0 0 2px #ffbbbb;letter-spacing:1px;z-index:101;box-shadow:0 4px 6px rgba(0,0,0,.05)}
        
        /* Shared Progress Containers */
        .progress-group-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 300px;
            z-index: 102;
        }
        .daily-progress-container, .spin-progress-container {
            background: #fff;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,.1);
            text-align: center;
            border-left: 5px solid #4a90e2; 
        }
        .spin-progress-container {
            border-left: 5px solid #ff8c00; 
        }
        .daily-progress-text, .spin-progress-text {font-size:14px;color:#333;margin-bottom:4px; font-weight: bold;}
        .daily-progress-bar, .spin-progress-bar {width:100%;height:12px;background:rgba(0,0,0,.1);border-radius:10px;overflow:hidden;margin-top:6px}
        .daily-progress-fill {height:100%;background:linear-gradient(90deg,#00f2fe,#4facfe);border-radius:10px;width:0%;transition:width .4s ease}
        .spin-progress-fill {height:100%;background:linear-gradient(90deg,#ff8c00, #ff4500);border-radius:10px;width:0%;transition:width .4s ease}

        /* Button Adjustments - Equal width for 5 buttons */
        .button-container{
            position:absolute;bottom:40px;left:50%;transform:translateX(-50%);
            display:grid; /* Change to grid for better control */
            grid-template-columns: repeat(5, 1fr); /* 5 equal columns (UPDATED) */
            gap: 8px; /* Slightly reduced gap */
            background:rgba(240,240,240,.9);padding:10px 10px; /* Reduced padding */
            border-radius:20px;box-shadow:0 4px 15px rgba(0,0,0,.1);backdrop-filter:blur(10px);
            width: 95%; /* Increased width for more space */
            max-width: 450px;
        }
        .nav-button{
            position:relative;background:linear-gradient(145deg,#4a90e2,#357abd);color:#fff;border:none;padding:10px 0; /* Adjust padding for height control */
            border-radius:10px;font-size:11px; /* Reduced font size for better fit */
            font-weight:bold;cursor:pointer;transition:all .1s ease;
            flex-grow: 1;
            min-width: auto;
            text-transform:uppercase;letter-spacing:.5px;box-shadow:0 5px 0 #2c5aa0,0 8px 12px rgba(0,0,0,.15);transform:translateY(0);
            text-align: center;
            line-height: 1; /* Ensure text fits */
        }
        .nav-button:hover{transform:translateY(-1px);box-shadow:0 6px 0 #2c5aa0,0 10px 15px rgba(0,0,0,.2)}
        .nav-button:active{transform:translateY(2px);box-shadow:0 3px 0 #2c5aa0,0 5px 8px rgba(0,0,0,.15)}
        .nav-button span{display:block;text-shadow:0 1px 2px rgba(0,0,0,.3)}

        .nav-button.task-btn{
            background:linear-gradient(145deg,#ffc107,#ff9800);
            box-shadow:0 5px 0 #cc9a00,0 8px 12px rgba(0,0,0,.15);
        }
        .nav-button.task-btn:hover{box-shadow:0 6px 0 #cc9a00,0 10px 15px rgba(0,0,0,.2)}
        .nav-button.task-btn:active{box-shadow:0 3px 0 #cc9a00,0 5px 8px rgba(0,0,0,.15)}

        /* NEW Style for Withdraw Nav Button */
        .nav-button.withdraw-btn-nav{
            background:linear-gradient(145deg,#ff2a2a,#cc2121);
            box-shadow:0 5px 0 #991919,0 8px 12px rgba(0,0,0,.15);
        }
        .nav-button.withdraw-btn-nav:hover{box-shadow:0 6px 0 #991919,0 10px 15px rgba(0,0,0,.2)}
        .nav-button.withdraw-btn-nav:active{box-shadow:0 3px 0 #991919,0 5px 8px rgba(0,0,0,.15)}

        /* ===== Task Screen - REDESIGNED STYLING ===== */
        .task-screen{
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content: flex-start; 
            padding-top: 50px; 
            padding-bottom: 120px; 
            overflow-y: auto;
            background: #ffffed; /* Light, paper-like background */
        }
        .task-header{ 
            text-align: center;
            margin-bottom: 30px;
            width: 90%;
            max-width: 350px;
        }
        .task-title{ 
             font-family: 'Vazirmatn', sans-serif; 
             font-size:24px; 
             color:#333; /* Dark pencil color */
             font-weight:700; 
             text-shadow: 1px 1px 0 #fff; 
             border-bottom: 2px dashed #a0a0a0;
             padding-bottom: 10px;
        }
        
        /* New Task Card Style based on user's input (Paper Style) */
        .task-content-container {
            width: 100%;
            padding: 0 10px;
            max-width: 400px;
        }

        .task-item-card {
            background:#ffffff; /* White card */
            margin:10px 0;
            padding:18px;
            border-radius:10px;
            display:flex;
            justify-content:space-between;
            align-items:center;
            border: 1px solid #ddd; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .task-text-info {
            color: #555; /* Slightly lighter text */
            font-size: 16px;
            font-weight: 500;
        }

        /* Button style from user's input (Pencil Style Action Button) */
        .task-action-btn-new {
            background:linear-gradient(145deg, #ffc107, #ff9800);
            border:1px solid #cc9a00;
            color:#fff;
            padding:10px 20px;
            border-radius:8px;
            cursor:pointer;
            font-size:1em;
            font-weight: bold;
            min-width: 90px; 
            transition: all 0.1s ease;
            box-shadow: 0 4px 0 #cc9a00;
            text-transform: uppercase;
        }
        .task-action-btn-new:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #cc9a00;
        }
        .task-action-btn-new:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #cc9a00;
        }
        .task-action-btn-new:disabled {
            background:#ccc;
            border-color:#aaa;
            color:#666;
            cursor:not-allowed;
            box-shadow: 0 4px 0 #aaa;
            transform: translateY(0);
        }
        
        .task-action-btn-new.completed {
            background:linear-gradient(145deg, #28a745, #1e7e34); /* Green for completed */
            border-color: #1c6d32;
            color: #fff;
            cursor: default;
            box-shadow: 0 4px 0 #1c6d32;
        }
        .task-action-btn-new.completed:disabled {
             background:linear-gradient(145deg, #1e7e34, #1c6d32); /* Darker green when disabled (after completion) */
             color: #ccc;
             box-shadow: 0 4px 0 #1c6d32;
        }
        
        /* Task Note style - REMOVED */
        .task-screen .note{ display: none; }

        /* Back Button Style - FIXED at bottom */
        .task-back-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background:linear-gradient(145deg, #6c757d, #5a6268);
            color:#fff;border:none;padding:15px 40px; /* Larger padding */
            border-radius:12px;
            font-size:16px;
            font-weight:bold;
            cursor:pointer;
            box-shadow:0 6px 0 #4e555b; /* Larger shadow */
            transition:all .1s ease;
            width: 90%;
            max-width: 350px;
            z-index: 1000; /* Ensure it's above other elements */
        }
        .task-back-btn:active{transform:translateY(3px) translateX(-50%);box-shadow:0 3px 0 #4e555b}
        
        /* ===== Spin Screen ===== */
        .spin-screen{
            display:flex;flex-direction:column;align-items:center;justify-content:center;
            transition:opacity .3s ease;
        }
        #wheelBox{position:relative;margin-bottom:25px}
        #wheelCanvas{
            border-radius:50%;
            /* Enhanced 3D Look */
            box-shadow:0 0 0 10px #eee, 0 15px 35px rgba(0,0,0,0.4); 
            background-color: #fefefe; 
            border: 2px solid #ccc; 
        }
        .arrow{
            position:absolute;top:-16px;left:50%;transform:translateX(-50%);
            width:0;height:0;border-left:18px solid transparent;border-right:18px solid transparent;
            border-top:28px solid #ff3366;filter:drop-shadow(0 3px 2px rgba(0,0,0,.3));z-index:10;
        }
        .spin-btn{background:#ff3366;color:#fff;border:none;padding:12px 35px;border-radius:30px;font-size:16px;font-weight:bold;cursor:pointer;box-shadow:0 6px 0 #cc2950;transition:all .1s ease}
        .spin-btn:active{transform:translateY(3px);box-shadow:0 3px 0 #cc2950}
        .spin-result{margin-top:18px;font-size:18px;color:#333}
        .spin-back{margin-top:25px;background:#6c757d;color:#fff;border:none;padding:10px 25px;border-radius:8px;font-size:15px;font-weight:bold;cursor:pointer;box-shadow:0 4px 0 #5a6268}
        .spin-back:active{transform:translateY(2px);box-shadow:0 2px 0 #5a6268}

        /* ===== Withdraw Screen - (No changes needed) ===== */
        .withdraw-screen{
            display:flex;flex-direction:column;align-items:center;padding:20px 20px;
            transition:opacity .3s ease;
            overflow-y: auto;
        }
        .withdraw-header{
            text-align: center;
            margin-bottom: 25px;
            width: 100%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 15px;
        }
        .withdraw-title{
            font-size:28px;color:#ff2a2a;font-weight:700; text-shadow: 0 1px 1px rgba(0,0,0,.1);
        }
        .current-balance-info{
            font-size: 16px;
            color: #555;
            margin-top: 10px;
            font-weight: bold;
        }
        .input-form-container {
            width: 100%;
            max-width: 400px;
            background: #fff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 6px 20px rgba(0,0,0,.1);
            border: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .input-group{
            width:100%;margin-bottom:15px;
        }
        .input-group label{display:block;margin-bottom:8px;font-size:14px;color:#555;font-weight:600;}
        .input-group input{width:100%;padding:12px 15px;border:1px solid #ddd;border-radius:10px;font-size:16px;transition:border-color .3s ease, box-shadow .3s ease;outline:none;}
        .input-group input:focus{border-color:#ff8c00;box-shadow:0 0 0 3px rgba(255,140,0,0.2);}
        .withdraw-buttons{display:flex;gap:15px;margin-top:20px;justify-content: center;}
        .withdraw-btn{
            background:linear-gradient(145deg, #28a745, #1e7e34);
            color:#fff;border:none;padding:12px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;
            box-shadow:0 5px 0 #1c6d32;transition:all .1s ease;
            width: 100%;
        }
        .withdraw-btn:active{transform:translateY(3px);box-shadow:0 2px 0 #1c6d32}
        .back-btn{
            background:linear-gradient(145deg, #6c757d, #5a6268);
            color:#fff;border:none;padding:12px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;
            box-shadow:0 5px 0 #4e555b;transition:all .1s ease;
        }
        .back-btn:active{transform:translateY(3px);box-shadow:0 2px 0 #4e555b}
        .note{margin-top:15px;font-size:13px;color:#777;max-width:400px;text-align:center;background:rgba(255,140,0,0.1);padding:10px;border-radius:10px;border-left: 5px solid #ff8c00;}

        /* Withdrawal History Table */
        .history-section{
            width: 100%;
            max-width: 400px;
            margin-top: 30px;
            padding: 20px 0;
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 15px;
        }
        .history-title{
            font-size: 20px;
            color: #333;
            margin-bottom: 15px;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
        }
        .history-table{
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .history-table th, .history-table td{
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        .history-table th{
            background-color: #f8f8f8;
            color: #555;
            font-weight: 600;
        }
        .history-table .status-pending{color: #ff8c00; font-weight: bold;}
        .history-table .status-completed{color: #28a745; font-weight: bold;}
        .no-records{text-align: center; color: #999; padding: 20px;}

        /* ===== Invite Screen - (No changes needed) ===== */
        .invite-screen{
            display:flex;flex-direction:column;align-items:center;padding:20px 20px;
            transition:opacity .3s ease;
            overflow-y: auto;
        }
        .invite-header{
            text-align: center;
            margin-bottom: 25px;
            width: 100%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 15px;
        }
        .invite-title{
            font-size:28px;color:#4a90e2;font-weight:700; text-shadow: 0 1px 1px rgba(0,0,0,.1);
        }
        .referrals-count-info{
            font-size: 18px;
            color: #333;
            margin-top: 15px;
            font-weight: bold;
            padding: 10px 15px;
            background: #e6f0ff;
            border-radius: 10px;
            border: 1px solid #cce0ff;
            box-shadow: 0 2px 5px rgba(0,0,0,.05);
            width: 100%;
        }
        .invite-buttons{
            width: 100%;
            margin-top: 15px;
        }
        .copy-link-btn{
            background:linear-gradient(145deg, #00bfff, #0077b3);
            color:#fff;border:none;padding:12px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;
            box-shadow:0 5px 0 #005a8d;transition:all .1s ease;
            width: 100%;
        }
        .copy-link-btn:active{transform:translateY(3px);box-shadow:0 2px 0 #005a8d}
        
        /* ===== Custom Alert (No changes needed) ===== */
        .custom-alert-overlay{
            position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;justify-content:center;
            align-items:center;z-index:10000;opacity:0;pointer-events:none;transition:opacity .3s ease;
        }
        .custom-alert-overlay.visible{opacity:1;pointer-events:auto}
        .custom-alert-box{
            background:#fff;padding:30px;border-radius:15px;text-align:center;max-width:320px;
            width:90%;box-shadow:0 10px 25px rgba(0,0,0,.2);transform:scale(.95);transition:transform .3s ease;
        }
        .custom-alert-overlay.visible .custom-alert-box{transform:scale(1)}
        .alert-icon{font-size:40px;margin-bottom:15px}
        .alert-title{font-size:22px;font-weight:bold;margin-bottom:10px;color:#333}
        .alert-message{font-size:16px;color:#555;margin-bottom:20px;white-space:pre-wrap}
        .alert-close-btn{
            background:linear-gradient(145deg, #8B4513, #6B3E26); /* Pencil/Brown style */
            color:#fff;border:none;padding:10px 25px;
            border-radius: 8px; font-size: 15px; font-weight: bold; cursor: pointer; 
            box-shadow: 0 4px 0 #543b27; transition: all 0.1s ease;
        }
        .alert-close-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #543b27; }

        /* Specific styles for Success */
        .custom-alert-box.success .alert-title { color: #28a745; }
        .custom-alert-box.success .alert-icon::before { content: '‚úÖ'; } 

        /* Specific styles for Error/Warning */
        .custom-alert-box.error .alert-title { color: #dc3545; }
        .custom-alert-box.error .alert-icon::before { content: '‚ùå'; } 

        /* Specific styles for Warning/Info - Using Yellow/Brown for Pencil/Paper Theme */
        .custom-alert-box.warning .alert-title { color: #8B4513; } /* Brown */
        .custom-alert-box.warning .alert-icon::before { content: '‚ö†Ô∏è'; } /* Warning Icon */
        
        /* Specific styles for Info - Using Blue/Light Blue */
        .custom-alert-box.info .alert-title { color: #4a90e2; } /* Blue */
        .custom-alert-box.info .alert-icon::before { content: '‚ÑπÔ∏è'; } /* Info Icon */
        
        /* New style for No Tasks Message */
        .no-tasks-message {
            padding: 20px;
            border: 1px dashed #ddd;
            border-radius: 10px;
            background: #fff;
            margin-top: 20px;
        }

    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="spinner-circle"></div>
    </div>
    
    <div class="app-screen main-screen" id="mainScreen">
        <div class="balance" id="shibBalance">0 SHIB</div>
        
        <div class="progress-group-container">
            <div class="daily-progress-container">
                <div class="daily-progress-text">Ads today: <span id="adsCount">0</span> / 100</div>
                <div class="daily-progress-bar">
                    <div class="daily-progress-fill" id="dailyProgressFill"></div>
                </div>
            </div>
            <div class="spin-progress-container">
                <div class="spin-progress-text">Spins today: <span id="spinsCount">0</span> / 15</div>
                <div class="spin-progress-bar">
                    <div class="spin-progress-fill" id="spinProgressFill"></div>
                </div>
            </div>
        </div>

        <div class="user-circle" onclick="circleClick()">
            <img id="userImage" alt="User Photo">
            <span class="placeholder">Click Me</span>
        </div>
        <div class="user-username" id="userName">Loading...</div>
        <div class="user-id" id="userId">ID: 0</div>

        <div class="button-container">
            <button class="nav-button task-btn" onclick="showTask()"><span class="nav-icon">‚≠ê</span> <span class="nav-text">Tasks</span></button>
            <button class="nav-button" onclick="watchAds()"><span class="nav-icon">üì∫</span> <span class="nav-text">Watch Ads</span></button>
            <button class="nav-button" onclick="showSpin()"><span class="nav-icon">üé∞</span> <span class="nav-text">Spin</span></button>
            <button class="nav-button withdraw-btn-nav" onclick="showWithdraw()"><span class="nav-icon">üí∞</span> <span class="nav-text">Withdraw</span></button>
            <button class="nav-button" onclick="showInvite()"><span class="nav-icon">üë•</span> <span class="nav-text">Invite</span></button>
        </div>
    </div>
    
    <div class="app-screen task-screen" id="taskScreen">
        <div class="task-header">
            <div class="task-title">Special Tasks ‚úçÔ∏è</div>
        </div>
        
        <div class="task-content-container" id="tasksListContainer">
            <div class="no-tasks-message" id="noTasksMessage" style="display: none;">
                No active tasks at the moment.
            </div>
            </div>

        <button class="task-back-btn" onclick="hideTask()">Back</button>
    </div>
    
    <div class="app-screen spin-screen" id="spinScreen">
        <div id="wheelBox">
            <canvas id="wheelCanvas" width="300" height="300"></canvas>
            <div class="arrow"></div>
        </div>
        <button class="spin-btn" id="spinBtn" onclick="spinWheel()">SPIN</button>
        <div class="spin-result" id="spinResult">Spin up to 15 times a day!</div>
        <button class="spin-back" onclick="hideSpin()">Back</button>
    </div>

    <div class="app-screen withdraw-screen" id="withdrawScreen">
        <div class="withdraw-header">
            <div class="withdraw-title">Withdraw SHIB</div>
            <div class="current-balance-info">Current Balance: <span id="withdrawBalanceDisplay">0</span> SHIB</div>
        </div>
        
        <div class="input-form-container">
            <div class="input-group">
                <label for="binanceIdInput">Your Binance ID (UID)</label>
                <input type="number" id="binanceIdInput" placeholder="Enter your 8-10 digit Binance UID" min="1" required>
            </div>
            <div class="input-group">
                <label for="withdrawAmountInput">Amount to Withdraw (Min. 10,000 SHIB)</label>
                <input type="number" id="withdrawAmountInput" placeholder="Enter amount" min="10000" required>
            </div>
            <div class="withdraw-buttons">
                <button class="withdraw-btn" onclick="requestWithdrawal()">Request Withdrawal</button>
            </div>
        </div>
        
        <div class="note">
            ‚ö†Ô∏è The minimum withdrawal is 10,000 SHIB. Transfers will be processed to your **Binance ID** within 24 hours.
        </div>
        
        <div class="history-section">
            <div class="history-title">Withdrawal History</div>
            <table class="history-table" id="withdrawalHistoryTable">
                <thead>
                    <tr>
                        <th>Amount</th>
                        <th>Date</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
            <div class="no-records" id="noWithdrawalRecords" style="display: none;">No withdrawal records found.</div>
        </div>
        
        <button class="back-btn" onclick="hideWithdraw()">Back to Main</button>
    </div>

    <div class="app-screen invite-screen" id="inviteScreen">
        <div class="invite-header">
            <div class="invite-title">Invite & Earn üë•</div>
            <div class="referrals-count-info">You have <span id="referralsCountDisplay">0</span> referrals!</div>
        </div>
        
        <div class="input-form-container">
            <div class="input-group">
                <label>Your Referral Link</label>
                <input type="text" id="referralLinkInput" readonly value="Generating Link...">
            </div>
            <div class="invite-buttons">
                <button class="copy-link-btn" onclick="copyReferralLink()">Copy Link</button>
            </div>
        </div>
        
        <div class="note">
            üöÄ Share this link to invite new users. You will earn 5% of the revenue from every referral you bring through ads!
        </div>
        
        <button class="back-btn" onclick="hideInvite()">Back to Main</button>
    </div>

    <div id="customAlert" class="custom-alert-overlay">
        <div class="custom-alert-box">
            <div class="alert-icon" id="alertIcon"></div>
            <div class="alert-title" id="alertTitle"></div>
            <div class="alert-message" id="alertMessage"></div>
            <button class="alert-close-btn" onclick="document.getElementById('customAlert').classList.remove('visible')">OK</button>
        </div>
    </div>

    <audio id="backgroundAudio" loop>
        <source src="audio.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>
    <audio id="successSFX">
        <source src="success.mp3" type="audio/mp3">
    </audio>
    <audio id="errorSFX">
        <source src="error.mp3" type="audio/mp3">
    </audio>

    <script src='//libtl.com/sdk.js' data-zone='10245709'></script>
    <script>
        /* ===== Global State and Configuration ===== */
        Telegram.WebApp.ready();

        const API_URL = '/api'; // Assuming the API is hosted on the same domain at the /api path.
        const DAILY_MAX = 100;
        const DAILY_MAX_SPINS = 15;
        const MIN_WITHDRAW_AMOUNT = 10000;

        let tgUser = null;
        if(Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user){
            tgUser = Telegram.WebApp.initDataUnsafe.user;
            const photoUrl = tgUser.photo_url;
            const userName = tgUser.first_name + (tgUser.last_name? ' '+tgUser.last_name:'');
            const userId = tgUser.id;

            const imgEl = document.getElementById('userImage');
            const nameEl = document.getElementById('userName');
            const idEl = document.getElementById('userId');
            const placeHolder = document.querySelector('.placeholder');

            if(photoUrl){
                imgEl.src = photoUrl;
                imgEl.style.display = 'block';
                placeHolder.style.display = 'none';
            }
            nameEl.textContent = userName;
            idEl.textContent = 'ID: ' + userId;
        }

        let state = {
            balance: 0,
            ads_watched_today: 0,
            spins_today: 0,
            referrals_count: 0,
            is_banned: false,
            withdrawal_history: [],
            dynamicTasks: [], // ‚¨ÖÔ∏è NEW: To hold tasks fetched from server
        };

        let countdownInterval = null;
        let isProcessingTask = false;
        let referrerId = getRefParam();
        
        function getRefParam() {
            let referrerId = null;
            const REF_PREFIX = 'ref_';
            if (Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.start_param) {
                const startParam = Telegram.WebApp.initDataUnsafe.start_param;
                if (startParam.startsWith(REF_PREFIX)) {
                    referrerId = startParam.substring(REF_PREFIX.length);
                    console.log('Referrer ID from start_param:', referrerId);
                }
            }
            return referrerId;
        }

        /* ===== UI Update and Navigation ===== */
        const mainScreen = document.getElementById('mainScreen');
        const loadingScreen = document.getElementById('loadingScreen');
        
        function updateState(newState) {
            Object.assign(state, newState);
            updateUI();
        }

        function updateUI() {
            document.getElementById('shibBalance').textContent = state.balance.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) + ' SHIB';
            document.getElementById('adsCount').textContent = state.ads_watched_today;
            document.getElementById('spinsCount').textContent = state.spins_today;
            document.getElementById('dailyProgressFill').style.width = `${(state.ads_watched_today / DAILY_MAX) * 100}%`;
            document.getElementById('spinProgressFill').style.width = `${(state.spins_today / DAILY_MAX_SPINS) * 100}%`;
            document.getElementById('referralsCountDisplay').textContent = state.referrals_count;
            
            // Update Spin Button State
            const spinBtn = document.getElementById('spinBtn');
            if (state.is_banned || state.spins_today >= DAILY_MAX_SPINS) {
                spinBtn.disabled = true;
                spinBtn.textContent = `LIMIT REACHED (${state.spins_today}/${DAILY_MAX_SPINS})`;
            } else if (!spinning) {
                spinBtn.disabled = false;
                spinBtn.textContent = 'SPIN';
            }
            
            // Update Ad Button State (Assuming the ad button is for watching, if one is needed on main screen)
            const adNavButton = document.querySelector('.nav-button[onclick="watchAds()"]');
             if (adNavButton) {
                if (state.ads_watched_today >= DAILY_MAX) {
                    adNavButton.disabled = true;
                    adNavButton.querySelector('.nav-text').textContent = 'Limit Reached';
                } else {
                    adNavButton.disabled = false;
                    adNavButton.querySelector('.nav-text').textContent = 'Watch Ads';
                }
            }
            
            // Update Withdraw Screen Balance
            const withdrawBalanceDisplay = document.getElementById('withdrawBalanceDisplay');
            if (withdrawBalanceDisplay) {
                withdrawBalanceDisplay.textContent = state.balance.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            
            // Render Tasks on Task Screen
            if (document.getElementById('taskScreen').classList.contains('visible')) {
                renderTasks();
            }
        }

        function showCustomAlert(title, message, type = 'info', sfx = true) {
            const alertOverlay = document.getElementById('customAlert');
            const alertBox = alertOverlay.querySelector('.custom-alert-box');
            document.getElementById('alertTitle').textContent = title;
            document.getElementById('alertMessage').textContent = message;
            
            alertBox.className = 'custom-alert-box ' + type;
            alertOverlay.classList.add('visible');
            
            // Play SFX
            if (sfx) {
                const audio = document.getElementById(type === 'success' ? 'successSFX' : 'errorSFX');
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(e => console.error("SFX Play failed:", e));
                }
            }
        }
        
        function playBGAudio() {
            const audio = document.getElementById('backgroundAudio');
            if (audio) {
                audio.volume = 0.5; 
                audio.play().catch(e => console.log("Auto-play blocked, wait for user interaction.", e));
            }
        }


        /* ===== API Fetch Wrapper ===== */
        async function fetchApi(payload) {
            if (typeof Telegram.WebApp.showProgress === 'function') {
                Telegram.WebApp.showProgress();
            }
            
            const fullPayload = {
                ...payload,
                initData: Telegram.WebApp.initData || '',
                user_id: tgUser ? tgUser.id : null,
                referrer_id: payload.type === 'register' ? referrerId : null
            };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(fullPayload)
                });
                
                if (typeof Telegram.WebApp.hideProgress === 'function') {
                    Telegram.WebApp.hideProgress();
                }

                const data = await response.json();

                if (!response.ok || !data.ok) {
                    const errorMessage = data.error || response.statusText;
                    let alertTitle = 'Operation Failed!';
                    let alertType = 'error';
                    let cleanMessage = errorMessage;

                    // Arabic Error Handling (for better user experience)
                    if (errorMessage.includes('Rate limit exceeded')) {
                        alertTitle = 'ÿ•ÿ¨ÿ±ÿßÿ° ÿ≥ÿ±Ÿäÿπ ÿ¨ÿØÿßŸã!';
                        alertType = 'warning';
                        cleanMessage = 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ŸÇŸÑŸäŸÑÿßŸã ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.';
                    } else if (errorMessage.includes('limit reached') || errorMessage.includes('Daily limit reached')) {
                        alertTitle = 'ÿßŸÑÿ≠ÿØ ÿßŸÑŸäŸàŸÖŸä!';
                        alertType = 'warning';
                        cleanMessage = 'ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ÿßŸÑŸäŸàŸÖŸä. ÿπÿØ ŸÑÿßÿ≠ŸÇÿßŸã.';
                    } else if (errorMessage.includes('User not found') || errorMessage.includes('Invalid or expired initData')) {
                        alertTitle = 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ£ŸÖÿßŸÜ!';
                        alertType = 'error';
                        cleanMessage = 'ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿ£ŸÖŸÜŸä. ŸÇÿØ ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÖÿµÿ∫ÿ±.';
                    } else if (response.status === 409 || response.status === 408) {
                        alertTitle = 'ÿÆÿ∑ÿ£ ÿ£ŸÖÿßŸÜ!';
                        alertType = 'error';
                        cleanMessage = 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÖÿ™ÿπŸÑŸÇ ÿ®ÿßŸÑÿ£ŸÖÿßŸÜ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.';
                    } else if (payload.type === 'completeTask' && errorMessage.includes('already completed')) {
                        alertTitle = 'ÿ™ŸÖ ÿ•ŸÉŸÖÿßŸÑ ÿßŸÑŸÖŸáŸÖÿ©!';
                        alertType = 'warning';
                        cleanMessage = 'ÿ™ŸÖÿ™ ÿßŸÑŸÖÿ∑ÿßŸÑÿ®ÿ© ÿ®ÿßŸÑŸÖŸÉÿßŸÅÿ£ÿ© ÿ®ÿßŸÑŸÅÿπŸÑ. ÿßŸÑŸÖŸáŸÖÿ© ŸÖŸÉÿ™ŸÖŸÑÿ©.';
                    } else if (payload.type === 'completeTask' && errorMessage.includes('not met the task requirements')) {
                        alertTitle = 'ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ!';
                        alertType = 'error';
                        cleanMessage = 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ŸÉŸÖÿßŸÑ ŸÖÿ™ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖŸáŸÖÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.';
                    } else {
                        // General error handling (Arabic)
                        alertTitle = 'ŸÅÿ¥ŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ©!';
                        alertType = 'error';
                        cleanMessage = errorMessage;
                    }
                    showCustomAlert(alertTitle, cleanMessage, alertType);
                    return { ok: false, error: errorMessage };
                }

                return data;

            } catch (error) {
                if (typeof Telegram.WebApp.hideProgress === 'function') {
                    Telegram.WebApp.hideProgress();
                }
                console.error(`General Fetch Error for type ${payload.type}:`, error.message);
                // Arabic translation of the alert message
                showCustomAlert('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ!', 'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿÆÿßÿØŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™.', 'error');
                return { ok: false, error: error.message };
            }
        }

        // ------------------------------------------------------------------
        // NEW: Function to request Action ID from the Server
        // ------------------------------------------------------------------
        async function requestActionId(actionType) {
            const result = await fetchApi({ type: 'requestActionId', action_type: actionType });
            if (result.ok) {
                return result.data.action_id;
            }
            return null; // Error message already shown by fetchApi
        }

        /* ===== Initial Load and Registration ===== */
        async function registerUser() {
            if (!tgUser) {
                 showCustomAlert('User Error!', 'Could not get Telegram user data. Please open the Mini App from a Telegram chat.', 'error');
                return;
            }
            const result = await fetchApi({ type: 'register' });

            if (result.ok) {
                // Initial data load after registration
                await loadUserData(); 
                loadingScreen.classList.add('hidden');
                mainScreen.classList.add('visible');
            } else if (result.error && result.error.includes('already exists')) {
                // User already registered, proceed to data load
                await loadUserData();
                loadingScreen.classList.add('hidden');
                mainScreen.classList.add('visible');
            } else {
                // Registration failed for other reasons (e.g., banned)
                showCustomAlert('Registration Failed!', result.error, 'error');
            }
        }

        async function loadUserData() {
            if (!tgUser) return;
            const result = await fetchApi({ type: 'getUserData' });
            
            if (result.ok) {
                if (result.data.is_banned) {
                    state.is_banned = true;
                    mainScreen.classList.remove('visible');
                    // Arabic translation of the alert message
                    showCustomAlert('ÿ™ŸÖ ÿ≠ÿ∏ÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ®!', 'ÿ™ŸÖ ÿ™ŸÇŸäŸäÿØ Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ®ÿ¥ŸÉŸÑ ÿØÿßÿ¶ŸÖ ŸÑÿßŸÜÿ™ŸáÿßŸÉŸá ÿßŸÑÿ≥Ÿäÿßÿ≥ÿßÿ™. ŸäŸèŸÖŸÜÿπ ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÖÿµÿ∫ÿ±.', 'error');
                    return;
                }
                
                // Update Global State
                updateState({
                    balance: result.data.balance,
                    ads_watched_today: result.data.ads_watched_today,
                    spins_today: result.data.spins_today,
                    referrals_count: result.data.referrals_count,
                    is_banned: false,
                    withdrawal_history: (result.data.withdrawal_history || []).map(item => ({ amount: item.amount, status: item.status, date: new Date(item.created_at).toLocaleDateString('en-GB') })),
                    dynamicTasks: result.data.tasks || [] // ‚¨ÖÔ∏è NEW: Capture the dynamic tasks array
                }); 
                
                mainScreen.classList.add('visible');
            }
        }

        // Run registration/load on start
        registerUser();

        /* ===== Ads Watching (No changes needed for core logic) ===== */
        async function watchAds(){
            if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }
            if (state.ads_watched_today >= DAILY_MAX) {
                showCustomAlert('ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑŸäŸàŸÖŸä!', `ÿ™ŸÖÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿπŸÑÿßŸÜÿßÿ™ ÿßŸÑŸäŸàŸÖ (${DAILY_MAX}). ÿπÿØ ÿ®ÿπÿØ 6 ÿ≥ÿßÿπÿßÿ™!`, 'warning');
                return;
            }
            
            // 1. Request Action ID from the Server
            const actionId = await requestActionId('watchAd');
            if (!actionId) return; 

            // 2. Show First Ad
            show_10245709()
            .then(() => {
                // Success for Ad 1 - Immediately start the second ad
                return show_10245709();
            })
            .then(async () => {
                // Success for Ad 2 - Confirm with server
                const result = await fetchApi({
                    type: 'watchAd',
                    action_id: actionId 
                });

                if (result.ok) {
                    // Update state and show success alert
                    updateState({ 
                        balance: result.data.new_balance,
                        ads_watched_today: result.data.ads_watched_today 
                    });
                    showCustomAlert('Success!', `Earned ${result.data.reward} SHIB!`, 'success');
                } else {
                    // Server check failed (e.g., rate limit, security)
                    await loadUserData();
                }
            })
            .catch(async (e) => {
                // Ad error/cancellation handling
                if (typeof e === 'string' && e.includes('canceled')) {
                    showCustomAlert('ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ•ÿπŸÑÿßŸÜ/ŸÅÿ¥ŸÑ!', 'ŸÑŸÖ ÿ™ÿ™ŸÖ ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿ•ÿπŸÑÿßŸÜ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ. ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≠ÿ™ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©.', 'warning');
                } else {
                    showCustomAlert('ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπŸÑÿßŸÜ!', 'ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπŸÑÿßŸÜ. ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≠ÿ™ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', 'error');
                }
                await loadUserData();
            });
        }
        
        function circleClick(){ 
            // Optional: Add functionality for the user circle click
            console.log('User circle clicked');
        }

        /* ===== Dynamic Task Screen Functions (NEW LOGIC) ===== */

        function renderTasks() {
            const container = document.getElementById('tasksListContainer');
            const noTasksMessage = document.getElementById('noTasksMessage');
            
            // Clear previous tasks and countdown interval
            container.innerHTML = '';
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
                isProcessingTask = false;
            }
            
            if (state.dynamicTasks.length === 0) {
                noTasksMessage.style.display = 'block';
                return;
            }
            
            noTasksMessage.style.display = 'none';

            state.dynamicTasks.forEach(task => {
                const card = document.createElement('div');
                card.className = 'task-item-card';
                
                let buttonText;
                let buttonClass = 'task-action-btn-new';
                let buttonDisabled = false;
                
                if (task.completed) {
                    buttonText = 'Completed';
                    buttonClass += ' completed';
                    buttonDisabled = true;
                } else if (task.action_state === 'CLAIM') {
                    // If state is CLAIM, check if a countdown is running for this task
                    if (isProcessingTask) {
                        buttonText = `Claiming... ${task.countdown || 5}s`;
                        buttonDisabled = true;
                    } else {
                        buttonText = 'Claim';
                        // Re-enable claim button if not processing and state is CLAIM
                        buttonDisabled = false;
                    }
                } else { // JOIN_OR_ACTION
                    buttonText = task.task_type === 'channel_join' ? 'Join' : 'Go to Link';
                    buttonDisabled = false;
                }

                card.innerHTML = `
                    <div class="task-text-info">
                        <strong>${task.task_name}</strong>
                        <div style="font-size: 0.9em; color: #888;">Reward: ${task.reward.toLocaleString()} SHIB</div>
                    </div>
                    <button 
                        class="${buttonClass}" 
                        id="taskBtn-${task.id}"
                        onclick="handleTaskAction(${task.id}, '${task.task_type}', '${task.target_value}')"
                        ${buttonDisabled ? 'disabled' : ''}
                    >
                        ${buttonText}
                    </button>
                `;
                
                container.appendChild(card);
            });
        }
        
        // ** MODIFIED: Now displays the actual task screen ** function showTask(){
            if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('taskScreen').classList.add('visible');
            loadUserData(); // Load and render tasks every time the screen is opened
        }

        function hideTask(){
            // Clear any running countdown when leaving the screen
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
                isProcessingTask = false;
            }
            document.getElementById('taskScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }

        /**
         * Generic function for the second step: claiming the reward.
         * @param {number} taskId 
         */
        async function claimTaskReward(taskId){
            const task = state.dynamicTasks.find(t => t.id === taskId);
            const taskBtn = document.getElementById(`taskBtn-${taskId}`);

            if (!task || task.completed || isProcessingTask) return;
            
            if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }

            // Start processing state
            isProcessingTask = true;
            task.action_state = 'CLAIM'; // Ensure state is CLAIM
            
            // Start countdown
            const countdownTime = 5;
            let countdown = countdownTime;
            task.countdown = countdown;
            taskBtn.textContent = `Claiming... ${countdown}s`;
            taskBtn.disabled = true;

            countdownInterval = setInterval(() => {
                countdown--;
                task.countdown = countdown;
                taskBtn.textContent = `Claiming... ${countdown}s`;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    
                    // Proceed to final API call after countdown
                    handleFinalClaimAPI(taskId, taskBtn);
                }
            }, 1000);
        }
        
        async function handleFinalClaimAPI(taskId, taskBtn) {
             // 1. Request Action ID from the Server for task completion (security)
            const actionId = await requestActionId('completeTask');
            if (!actionId) {
                isProcessingTask = false;
                await loadUserData(); // Reload state in case of failure
                return; 
            }
            
            // 2. Send completion request via API
            const result = await fetchApi({
                type: 'completeTask',
                task_id: taskId,
                action_id: actionId 
            });

            isProcessingTask = false;
            
            if (result.ok) {
                // Success
                updateState({ balance: result.data.new_balance });
                showCustomAlert('Task Success!', `You earned ${result.data.actual_reward.toLocaleString()} SHIB!`, 'success');
            } else {
                // If the server returns an error about completion or not joined, reload state
                // The fetchApi wrapper already shows an Arabic error alert
            }
            await loadUserData(); // Reload data to update task status and UI
        }


        /**
         * Generic function for the first step: initiating the action (Join/Go to Link).
         * @param {number} taskId 
         * @param {string} taskType - e.g., 'channel_join'
         * @param {string} targetValue - e.g., 'https://t.me/botbababab'
         */
        function handleTaskAction(taskId, taskType, targetValue) {
            const task = state.dynamicTasks.find(t => t.id === taskId);
            const taskBtn = document.getElementById(`taskBtn-${taskId}`);

            if (!task || task.completed || isProcessingTask) return;

            if (task.action_state === 'CLAIM') {
                // If user clicks 'Claim', start the countdown/claim process
                claimTaskReward(taskId);
                return;
            }

            // First click: Redirect to the channel/link
            taskBtn.disabled = true; // Disable temporarily while opening link

            let link;
            if (taskType === 'channel_join') {
                link = targetValue; // Should be a full Telegram link e.g., 'https://t.me/channel_username'
                taskBtn.textContent = 'Joining...';
            } else {
                link = targetValue.startsWith('http') ? targetValue : `http://${targetValue}`;
                taskBtn.textContent = 'Opening...';
            }
            
            // Use Telegram WebApp function if available, otherwise fallback
            if (typeof Telegram.WebApp.openTelegramLink === 'function' && taskType === 'channel_join') {
                Telegram.WebApp.openTelegramLink(link);
            } else if (typeof Telegram.WebApp.openLink === 'function') {
                Telegram.WebApp.openLink(link);
            } else {
                window.open(link, '_blank');
            }

            // Update state and UI to prompt for the second click (claim)
            setTimeout(() => {
                const updatedTask = state.dynamicTasks.find(t => t.id === taskId);
                if (updatedTask && !updatedTask.completed) {
                    updatedTask.action_state = 'CLAIM'; // Mark state change locally
                }
                
                // Re-enable and set button text to 'Claim'
                if (taskBtn) {
                     taskBtn.disabled = false;
                     taskBtn.textContent = 'Claim';
                }
                
                // Show an instruction alert for the next step (Claim)
                showCustomAlert('Claim Reward!', 'After completing the task, click the **Claim** button to verify and get your reward.', 'info', false);
                
                // Re-render to ensure all buttons reflect the new state (optional, but safer)
                renderTasks(); 
                
            }, 1500); // 1.5 second delay
        }

        /* ===== Spin Wheel (No changes needed for core logic) ===== */
        const sectors = [5, 10, 15, 20, 5]; // SHIB Prizes
        const colors = ['#00bfff', '#ff8c00', '#28a745', '#ff4500', '#00f2fe']; 
        const prizeValues = sectors;
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinResult = document.getElementById('spinResult');
        const spinBtn = document.getElementById('spinBtn');
        
        let spinning = false;
        let currentAngle = 0;

        function drawWheel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 130;
            const sectorCount = sectors.length;
            const arc = 2 * Math.PI / sectorCount;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Prepare text style
            ctx.font = '16px Vazirmatn, sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < sectorCount; i++) {
                const angle = currentAngle + i * arc;
                
                // Draw sector arc
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, angle, angle + arc);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw text (prize)
                ctx.save();
                ctx.translate(centerX + Math.cos(angle + arc / 2) * radius * 0.7, centerY + Math.sin(angle + arc / 2) * radius * 0.7);
                ctx.rotate(angle + arc / 2 + Math.PI / 2);
                ctx.fillStyle = '#fff';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.fillText(`${prizeValues[i]} SHIB`, 0, 0);
                ctx.restore();
            }

            // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, 2 * Math.PI);
            ctx.fillStyle = '#ff3366';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function rotateWheel(targetAngle, duration) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const startAngle = currentAngle;
                
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(1, elapsed / duration);
                    
                    // Easing function (ease-out-quad)
                    const easedProgress = progress * (2 - progress);
                    
                    currentAngle = startAngle + (targetAngle - startAngle) * easedProgress;
                    drawWheel();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        currentAngle = targetAngle % (2 * Math.PI); // Normalize angle
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }
        
        function getPrizeIndex(finalAngle) {
            const normalizedAngle = (2 * Math.PI - (finalAngle % (2 * Math.PI))) % (2 * Math.PI);
            const sectorCount = sectors.length;
            const arc = 2 * Math.PI / sectorCount;
            return Math.floor(normalizedAngle / arc);
        }


        async function spinWheel() {
            if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }
            if (state.spins_today >= DAILY_MAX_SPINS) {
                return;
            }

            // 1. Request Action ID from the Server for pre-spin (security check)
            const preSpinActionId = await requestActionId('preSpin');
            if (!preSpinActionId) return; 

            // 2. Request pre-spin registration (Server checks for banned user and consumes the action ID)
            const preSpinReqResult = await fetchApi({ 
                type: 'preSpin', 
                action_id: preSpinActionId 
            });
            if (!preSpinReqResult.ok) {
                await loadUserData();
                return;
            }
            
            // 3. Request Action ID from the Server for the spin result (prize confirmation)
            const spinResultActionId = await requestActionId('spinResult');
            if (!spinResultActionId) {
                showCustomAlert('ÿÆÿ∑ÿ£ ÿ£ŸÖÿßŸÜ!', 'ŸÅÿ¥ŸÑ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ±ŸÖÿ≤ ÿßŸÑÿ™ÿ£ŸÉŸäÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', 'error');
                await loadUserData(); 
                return;
            }

            // 4. Call Ad SDK (libtl.com)
            show_10245709()
            .then(async () => {
                spinning = true;
                spinBtn.disabled = true;
                spinResult.textContent = 'Spinning...';

                // 5. Request spin result and prize addition (Server runs limits, Rate Limit, and validates Action ID)
                const spinResultRes = await fetchApi({ 
                    type: 'spinResult', 
                    action_id: spinResultActionId 
                });
                
                if (spinResultRes.ok) {
                    const { prize_index, prize_value, new_balance } = spinResultRes.data;
                    
                    // Calculate target angle to land on the server-determined prize
                    const sectorCount = sectors.length;
                    const arc = 2 * Math.PI / sectorCount;
                    // Calculate a random point within the target sector for visual variety
                    const randomOffset = Math.random() * arc;
                    // Add several full rotations (e.g., 5 full spins)
                    const fullRotations = 10 * 2 * Math.PI; 
                    
                    // Angle calculation: starts from 0 (top), moves clockwise. 
                    // Prize 0 is on top. prize_index=0 needs to land in the first sector.
                    // The center of the prize_index sector is at: (prize_index * arc) + (arc/2)
                    // We need to stop the pointer at the prize index.
                    // The wheel rotates counter-clockwise. To stop at prize_index, the final angle of the wheel must be:
                    // (2 * PI) - (center of prize_index sector) + (some full rotations)
                    // The center angle of sector 'i' is: (i * arc) + (arc / 2)
                    const angleToCenter = prize_index * arc + arc / 2;
                    const targetAngle = fullRotations + (2 * Math.PI) - angleToCenter + randomOffset - arc/2; 
                    
                    await rotateWheel(targetAngle, 4000); // 4 seconds duration
                    
                    spinning = false;
                    
                    if (prize_value > 0) {
                        spinResult.textContent = `Congrats! You won ${prize_value} SHIB!`;
                        showCustomAlert('Winner!', `You won ${prize_value.toLocaleString()} SHIB!`, 'success');
                    } else {
                        spinResult.textContent = `Try again next time!`;
                        showCustomAlert('Try Again!', `No prize this time. Better luck on your next spin!`, 'warning');
                    }
                    
                    // Update state with server data
                    updateState({ 
                        balance: new_balance,
                        spins_today: state.spins_today + 1 // Assuming server handles the real increment, but updating for immediate UI feedback
                    });
                    
                } else {
                    // Server error/limit reached during final check
                    spinResult.textContent = `Spin Failed.`;
                    showCustomAlert('Spin Failed!', 'An error occurred during prize confirmation. Please try again.', 'error');
                    await loadUserData();
                }
                
                spinning = false;
                updateUI(); // Re-enable button if possible

            })
            .catch(async (e) => {
                // Ad error/cancellation handling
                spinning = false;
                spinResult.textContent = `Spin Failed.`;
                if (typeof e === 'string' && e.includes('canceled')) {
                    showCustomAlert('ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ•ÿπŸÑÿßŸÜ/ŸÅÿ¥ŸÑ!', 'ŸÑŸÖ ÿ™ÿ™ŸÖ ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿ•ÿπŸÑÿßŸÜ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ. ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≠ÿ™ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©.', 'warning');
                } else {
                    showCustomAlert('ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπŸÑÿßŸÜ!', 'ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπŸÑÿßŸÜ. ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≠ÿ™ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', 'error');
                }
                await loadUserData(); // Ensure data is up to date
                updateUI();
            });
        }
        
        // Initial wheel draw
        drawWheel();

        /* ===== Navigation Functions (No changes needed) ===== */
        function showSpin(){
            if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('spinScreen').classList.add('visible');
            loadUserData();
            updateUI(); 
        }

        function hideSpin(){
            document.getElementById('spinScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }

        function showWithdraw(){
             if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('withdrawScreen').classList.add('visible');
            loadUserData(); 
            displayWithdrawals(); // Render history on open
            updateUI();
        }

        function hideWithdraw(){
            document.getElementById('withdrawScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }
        
        function showInvite(){
             if (state.is_banned) {
                showCustomAlert('ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ!', 'ÿ™ŸÖ ÿ≠ÿ∏ÿ± Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ®.', 'error');
                return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('inviteScreen').classList.add('visible');
            generateReferralLink();
            loadUserData();
            updateUI();
        }

        function hideInvite(){
            document.getElementById('inviteScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }

        /* ===== Withdraw Functions (No changes needed for core logic) ===== */
        function displayWithdrawals() {
            const tableBody = document.getElementById('withdrawalHistoryTable').querySelector('tbody');
            const noRecords = document.getElementById('noWithdrawalRecords');
            tableBody.innerHTML = '';
            
            if (state.withdrawal_history.length === 0) {
                noRecords.style.display = 'block';
                return;
            }
            noRecords.style.display = 'none';

            state.withdrawal_history.forEach(item => {
                const row = tableBody.insertRow();
                const statusClass = item.status === 'Completed' ? 'status-completed' : 'status-pending';
                
                row.innerHTML = `
                    <td>${item.amount.toLocaleString()} SHIB</td>
                    <td>${item.date}</td>
                    <td class="${statusClass}">${item.status}</td>
                `;
            });
        }

        async function requestWithdrawal(){
            const binanceId = document.getElementById('binanceIdInput').value;
            const amount = parseInt(document.getElementById('withdrawAmountInput').value);

            if (!binanceId || binanceId.length < 8 || binanceId.length > 10) {
                showCustomAlert('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ•ÿØÿÆÿßŸÑ!', 'Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÖÿπÿ±ŸÅ Binance (UID) ÿµÿßŸÑÿ≠ (8-10 ÿ£ÿ±ŸÇÿßŸÖ).', 'error');
                return;
            }
            if (isNaN(amount) || amount < MIN_WITHDRAW_AMOUNT) {
                showCustomAlert('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ•ÿØÿÆÿßŸÑ!', `ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ ŸÑŸÑÿ≥ÿ≠ÿ® ŸáŸà ${MIN_WITHDRAW_AMOUNT.toLocaleString()} SHIB.`, 'error');
                return;
            }
            if (amount > state.balance) {
                showCustomAlert('ÿ±ÿµŸäÿØ ÿ∫Ÿäÿ± ŸÉÿßŸÅ!', `ÿ±ÿµŸäÿØŸÉ ÿßŸÑÿ≠ÿßŸÑŸä ŸáŸà ${state.balance.toLocaleString()} SHIB.`, 'error');
                return;
            }
            
            // 1. Request Action ID from the Server
            const actionId = await requestActionId('withdraw');
            if (!actionId) return;

            // 2. Send withdrawal request via API
            const result = await fetchApi({
                type: 'withdraw',
                binanceId: binanceId,
                amount: amount,
                action_id: actionId // ‚¨ÖÔ∏è ÿ•ÿ±ÿ≥ÿßŸÑ Action ID
            });

            if (result.ok) {
                // 3. Update balance with trusted server value
                updateState({ balance: result.data.new_balance });
                
                // 4. Reload withdrawal history with new data
                await loadUserData(); 
                displayWithdrawals(); 
                
                // Arabic translation of the alert message
                showCustomAlert('ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ®!', `ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ:\nŸÖÿπÿ±ŸÅ Binance: ${binanceId}\nÿßŸÑŸÖÿ®ŸÑÿ∫: ${amount.toLocaleString()} SHIB\n\nÿ≥Ÿäÿ™ŸÖ ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ŸÅŸä ÿ∫ÿ∂ŸàŸÜ 24 ÿ≥ÿßÿπÿ©.`, 'success');
            }
        }

        /* ===== Invite Functions (No changes needed) ===== */
        function generateReferralLink() {
            if (!tgUser || !tgUser.id) return;
            // Link format: t.me/bot_username?start=ref_{user_id}
            const botUsername = Telegram.WebApp.initDataUnsafe.start_param ? Telegram.WebApp.initDataUnsafe.start_param.replace('ref_', '') : 'YOUR_BOT_USERNAME'; // Placeholder or dynamic if possible
            const link = `https://t.me/${botUsername}?start=ref_${tgUser.id}`;
            document.getElementById('referralLinkInput').value = link;
        }

        function copyReferralLink() {
            const linkInput = document.getElementById('referralLinkInput');
            linkInput.select();
            linkInput.setSelectionRange(0, 99999); // For mobile devices
            navigator.clipboard.writeText(linkInput.value)
            .then(() => {
                showCustomAlert('ÿ™ŸÖ ÿßŸÑŸÜÿ≥ÿÆ!', 'ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ•ÿ≠ÿßŸÑÿ© ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ©.', 'success');
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                showCustomAlert('ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ≥ÿÆ!', 'ŸÅÿ¥ŸÑ ŸÜÿ≥ÿÆ ÿßŸÑÿ±ÿßÿ®ÿ∑. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', 'error');
            });
        }
        
        // Final event listener to ensure background audio starts on the first user interaction
        document.addEventListener('click', function handler() {
            playBGAudio();
            document.removeEventListener('click', handler); // Remove after first successful click
        });

    </script>
</body>
</html>
